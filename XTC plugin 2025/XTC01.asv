classdef XTC01 < audioPlugin & matlab.System
    properties
        D = 1.0;
        dp = 0.2;
        do = 0.18;
        beta = 0.01;
    end
    properties(Nontunable)
        % ImpulseResponseDirect
        % Specify the direct impulse responses (hLL, hLR) from a stereo file.
        nSamplesIR = 8192; % Expects 2-channel: [hL; hR]

        % PartitionSize Length of each partition of the impulse reponse
        PartitionSize = 4096; %2048; %1024;
    end

    properties (Constant)
        PluginInterface = audioPluginInterface(...
            'InputChannels',2,... % Stereo input
            'OutputChannels',2,... % Stereo output
            'PluginName','CrosstalkConvolver'...
            );
    end

    properties(Access = private, Nontunable)
        pFIR_hL_xL % Filter for hL * xL
        pFIR_hLR_xR % Filter for hLR * xR
        pFIR_hRL_xL % Filter for hRL * xL
        pFIR_hR_xR % Filter for hR * xR
    end

    methods(Access = protected)
        function y = stepImpl(plugin,u)
            % u is the input audio, N-by-2 for stereo
            xL = u(:,1); % Left input channel
            xR = u(:,2); % Right input channel

            % Perform individual convolutions
            conv_hL_xL = step(plugin.pFIR_hL_xL, xL);
            conv_hLR_xR = step(plugin.pFIR_hLR_xR, xR);
            conv_hRL_xL = step(plugin.pFIR_hRL_xL, xL);
            conv_hR_xR = step(plugin.pFIR_hR_xR, xR);

            % Combine results as per the desired equations
            uL = conv_hL_xL + conv_hLR_xR; % uL = hL * xL + hLR * xR
            uR = conv_hRL_xL + conv_hR_xR; % uR = hRL * xL + hR * xR

            % Combine the output channels
            y = [uL, uR];
        end

        function setupImpl(plugin, u)
            fs=getSampleRate(plugin);
            [cLL, cLR] = transaural_ir(plugin.D, plugin.dp, plugin.do,...
                plugin.beta, plugin.nSamplesIR, fs);

            cLL=cRR;
            cLR=cRL;

            % Validate impulse response dimensions
            if size(plugin.ImpulseResponse, 1) ~= 2
                error('The ImpulseResponseDirect must be a stereo (2-channel) audio file.');
            end

            % Initialize all four FIR filters
            plugin.pFIR_hL_xL = dsp.FrequencyDomainFIRFilter(...
                'Numerator', cLL, ... % hL
                'PartitionForReducedLatency', true, 'PartitionLength', plugin.PartitionSize);
            setup(plugin.pFIR_hL_xL, u(:,1)); % Setup with left input

            plugin.pFIR_hLR_xR = dsp.FrequencyDomainFIRFilter(...
                'Numerator', cLR, ... % hLR
                'PartitionForReducedLatency', true, 'PartitionLength', plugin.PartitionSize);
            setup(plugin.pFIR_hLR_xR, u(:,2)); % Setup with right input

            plugin.pFIR_hRL_xL = dsp.FrequencyDomainFIRFilter(...
                'Numerator', cRL, ... % hRL
                'PartitionForReducedLatency', true, 'PartitionLength', plugin.PartitionSize);
            setup(plugin.pFIR_hRL_xL, u(:,1)); % Setup with left input

            plugin.pFIR_hR_xR = dsp.FrequencyDomainFIRFilter(...
                'Numerator', cRR, ... % hR
                'PartitionForReducedLatency', true, 'PartitionLength', plugin.PartitionSize);
            setup(plugin.pFIR_hR_xR, u(:,2)); % Setup with right input
        end

        function resetImpl(plugin)
            % Reset all four FIR filters
            reset(plugin.pFIR_hL_xL);
            reset(plugin.pFIR_hLR_xR);
            reset(plugin.pFIR_hRL_xL);
            reset(plugin.pFIR_hR_xR);
        end
        
        function processTunedPropertiesImpl(plugin)
            fs = getSampleRate(plugin);

            % Recalculamos la IR cada vez que un parámetro cambia
            [cLL, cLR] = transaural_ir(plugin.D, plugin.dp, plugin.do, ...
                plugin.beta, plugin.nSamplesIR, fs);
        
            % Asumimos simetría
            cRR = cLL;
            cRL = cLR;
    
            % Actualizamos la propiedad 'Numerator' de los filtros existentes
            plugin.pFIR_hL_xL.Numerator = cLL;
            plugin.pFIR_hLR_xR.Numerator = cLR;
            plugin.pFIR_hRL_xL.Numerator = cRL;
            
        end

        % Propagators (remain the same as they handle size and type based on input)
        function varargout = isOutputComplexImpl(~)
            varargout{1} = false;
        end

        function varargout = getOutputSizeImpl(obj)
            varargout{1} = propagatedInputSize(obj, 1);
        end

        function varargout = getOutputDataTypeImpl(obj)
            varargout{1} = propagatedInputDataType(obj, 1);
        end

        function varargout = isOutputFixedSizeImpl(obj)
            varargout{1} = propagatedInputFixedSize(obj,1);
        end
    end
end